// Define memory types locally
type Memory = {
    id: string;
    content: string;
    containerTags: string[];
    summary?: string;
    title: string;
}
import { useCallback, useEffect, useState } from "react"
import { useFetcher } from "react-router"
import { MemoryGraph } from "../components/MemoryGraph"

export function Welcome({
    message,
    userId,
    initialMemories,
    graphData,
}: {
    message: string
    userId: string
    initialMemories: Memory[]
    graphData?: {
        nodes: Array<{ id: string; label: string; group: number }>;
        links: Array<{ source: string; target: string; value: number }>;
    }
}) {
    const [selectedClient, setSelectedClient] = useState<string>("claude")
    const clients = [
        "claude",
        "cursor",
        "cline", 
        "roo-cline",
        "windsurf",
        "witsy",
        "enconvo",
    ]
    const currentUrl = "https://mcp.mindflux.ai"
    const [memories, setMemories] = useState<Memory[]>(initialMemories)
    const [isDeleting, setIsDeleting] = useState<string | null>(null)
    const [isEditing, setIsEditing] = useState<string | null>(null)
    const [editedTitle, setEditedTitle] = useState<string>("")
    const [countdown, setCountdown] = useState<number>(30)
    const [isRefreshing, setIsRefreshing] = useState<boolean>(false)
    const [restoreUrl, setRestoreUrl] = useState<string>("")
    const [isRestoring, setIsRestoring] = useState<boolean>(false)
    const fetcher = useFetcher()

    // Create a function to fetch data
    const fetchMemories = useCallback(() => {
        setIsRefreshing(true)
        const formData = new FormData()
        formData.append("userId", userId)
        formData.append("action", "fetch") // Add action field for fetching
        fetcher.submit(formData, {
            method: "post",
            action: "/?index",
        })
        // Reset countdown when manually fetching
        setCountdown(30)
    }, [userId, fetcher])

    // Function to delete a memory
    const deleteMemory = (memoryId: string) => {
        if (!memoryId) return
        setIsDeleting(memoryId)
        // Updated to use useFetcher with action field
        const formData = new FormData()
        formData.append("userId", userId)
        formData.append("action", "delete")
        formData.append("memoryId", memoryId)
        fetcher
            .submit(formData, {
                method: "post",
                action: "/?index",
            })
            .then(() => {
                console.log(fetcher.data)
                if (fetcher.data.success === true) {
                    setMemories((prev) =>
                        prev.filter((memory) => memory.id !== memoryId),
                    )
                }
            })
    }

    // Function to start editing a memory
    const startEditing = (memory: Memory) => {
        setIsEditing(memory.id)
        setEditedTitle(memory.title)
    }

    // Function to cancel editing
    const cancelEditing = () => {
        setIsEditing(null)
        setEditedTitle("")
    }

    // Function to restore a session from URL
    const restoreSession = async () => {
        if (!restoreUrl.trim()) {
            alert("Please enter a valid MCP URL")
            return
        }
        setIsRestoring(true)
        try {
            // Extract userId from URL
            // Expected format: https://mcp.mindflux.ai/USER_ID/sse or similar
            const urlPattern = /\/([^\/]+)\/sse/
            const match = restoreUrl.match(urlPattern)
            if (!match || !match[1]) {
                alert(
                    "Invalid URL format. Expected format: https://mcp.mindflux.ai/USER_ID/sse",
                )
                setIsRestoring(false)
                return
            }
            const extractedUserId = match[1]
            // Create form data for the restore action
            const formData = new FormData()
            formData.append("userId", extractedUserId)
            formData.append("action", "restore")
            fetcher.submit(formData, {
                method: "post",
                action: "/?index",
            })
            // Reset the input field
            setRestoreUrl("")
        } catch (error) {
            console.error("Error restoring session:", error)
            alert(
                `Failed to restore session: ${error instanceof Error ? error.message : String(error)}`,
            )
        } finally {
            setIsRestoring(false)
        }
    }

    // Function to update a memory
    const updateMemory = (memoryId: string) => {
        if (!memoryId || !editedTitle.trim()) return
        // Create form data for the update
        const formData = new FormData()
        formData.append("userId", userId)
        formData.append("action", "update")
        formData.append("memoryId", memoryId)
        formData.append("content", editedTitle.trim())
        fetcher
            .submit(formData, {
                method: "post",
                action: "/?index",
            })
            .then(() => {
                if (fetcher.data.success) {
                    // Update the memory in the local state
                    setMemories((prev) =>
                        prev.map((memory) =>
                            memory.id === memoryId
                                ? { ...memory, title: editedTitle.trim() }
                                : memory,
                        ),
                    )
                }
                // Reset editing state
                setIsEditing(null)
                setEditedTitle("")
            })
    }

    useEffect(() => {
        fetchMemories()
    }, [])

    // Countdown timer effect
    useEffect(() => {
        const timer = setInterval(() => {
            setCountdown((prev) => {
                if (prev <= 1) {
                    fetchMemories()
                    return 30
                }
                return prev - 1
            })
        }, 1000)
        return () => clearInterval(timer)
    }, [fetchMemories])

    // Handle fetcher data updates
    useEffect(() => {
        if (fetcher.data && fetcher.state === "idle") {
            // Handle successful response
            if (fetcher.data.memories) {
                setMemories(fetcher.data.memories)
            }
            // Handle error response
            if (fetcher.data.error) {
                console.error(
                    "Error with memory operation:",
                    fetcher.data.error,
                )
                alert(`Operation failed: ${fetcher.data.error}`)
            }
            // Reset deleting state if we were in the middle of a delete operation
            if (isDeleting) {
                setIsDeleting(null)
            }
            // Reset editing state if we were in the middle of an edit operation
            if (isEditing) {
                setIsEditing(null)
                setEditedTitle("")
            }
            // Reset refreshing state
            if (isRefreshing) {
                setIsRefreshing(false)
            }
        }
    }, [fetcher.data, fetcher.state])

    return (
        <main className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 relative overflow-hidden">
            {/* Animated background elements */}
            <div className="absolute inset-0">
                <div className="absolute top-20 left-10 w-72 h-72 bg-blue-500/10 rounded-full blur-3xl animate-pulse"></div>
                <div className="absolute bottom-20 right-10 w-96 h-96 bg-cyan-500/10 rounded-full blur-3xl animate-pulse delay-700"></div>
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[600px] h-[600px] bg-purple-500/5 rounded-full blur-3xl animate-pulse delay-1000"></div>
            </div>

            {/* Knowledge Graph */}
            <div className="relative w-full max-w-7xl mx-auto px-6 md:px-8 mb-12">
                {graphData && <MemoryGraph data={graphData} />}
            </div>

            {/* Subtle grid overlay */}
            <div className="absolute inset-0 bg-grid-pattern opacity-[0.02]"></div>

            {/* Content */}
            <div className="relative w-full max-w-7xl mx-auto px-6 md:px-8 mt-12">
                <div className="text-center mb-20">
                    <h1 className="text-4xl font-bold text-white mb-4">{message}</h1>
                    <p className="text-white/60">Your personal knowledge management system</p>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    {/* Left column - MCP URL */}
                    <div className="bg-slate-900/80 backdrop-blur-xl rounded-2xl border border-white/10 p-8">
                        <h2 className="text-2xl font-semibold mb-2 text-white/90">Your MCP URL</h2>
                        <div className="flex gap-2 mb-8">
                            <div className="flex-1 bg-slate-950/80 border border-white/10 rounded-xl p-4 font-mono text-sm">
                                <code className="text-blue-300">{currentUrl}/{userId}/sse</code>
                            </div>
                            <button
                                onClick={() => navigator.clipboard.writeText(`${currentUrl}/${userId}/sse`)}
                                className="p-4 bg-blue-600/20 hover:bg-blue-600/30 border border-blue-500/30 rounded-xl"
                            >
                                Copy
                            </button>
                        </div>

                        <div className="space-y-4">
                            <h3 className="text-lg font-medium text-white/80">Select Client:</h3>
                            <div className="flex flex-wrap gap-2">
                                {clients.map((client) => (
                                    <button
                                        key={client}
                                        onClick={() => setSelectedClient(client)}
                                        className={`px-4 py-2 rounded-lg border ${
                                            selectedClient === client
                                                ? "bg-blue-600/30 border-blue-500/50 text-blue-300"
                                                : "bg-slate-800/50 border-white/10 text-white/70"
                                        }`}
                                    >
                                        {client}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* Right column - Memories */}
                    <div className="bg-slate-900/80 backdrop-blur-xl rounded-2xl border border-white/10">
                        <div className="p-6 bg-slate-800/30 rounded-t-2xl flex justify-between items-center">
                            <h2 className="text-xl font-semibold text-white/90">Memories</h2>
                            <span className="bg-gradient-to-r from-blue-600 to-cyan-600 text-white text-xs px-3 py-1.5 rounded-full">
                                {memories.length} items
                            </span>
                        </div>

                        {memories.length > 0 ? (
                            <ul className="divide-y divide-white/5">
                                {memories.map((memory) => (
                                    <li key={memory.id} className="p-6">
                                        <div className="flex justify-between items-start">
                                            <div>
                                                {isEditing === memory.id ? (
                                                    <div className="flex gap-2">
                                                        <input
                                                            type="text"
                                                            value={editedTitle}
                                                            onChange={(e) => setEditedTitle(e.target.value)}
                                                            className="bg-slate-950/80 border border-blue-500/50 rounded-lg px-3 py-2"
                                                            autoFocus
                                                        />
                                                        <button onClick={() => updateMemory(memory.id)}>Save</button>
                                                        <button onClick={cancelEditing}>Cancel</button>
                                                    </div>
                                                ) : (
                                                    <div className="text-white/80">{memory.content}</div>
                                                )}
                                                <div className="text-sm text-white/40 mt-2">ID: {memory.id}</div>
                                            </div>
                                            <div className="flex gap-2">
                                                <button
                                                    onClick={() => startEditing(memory)}
                                                    className="text-white/60 hover:text-white"
                                                >
                                                    Edit
                                                </button>
                                                <button
                                                    onClick={() => deleteMemory(memory.id)}
                                                    className="text-white/60 hover:text-red-400"
                                                >
                                                    Delete
                                                </button>
                                            </div>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        ) : (
                            <div className="p-12 text-center">
                                <p className="text-white/60">No memories yet</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </main>
    );
}